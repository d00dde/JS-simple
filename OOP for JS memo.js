window.onload = function () {



function MyClass (param) {  //Параметры конструктора приравниваются к private свойствам
	
	const IMPORTENT_CONST = 0;      //Внутренняя константа, название записывается прописью 
	let name = 'Class';        //Внутренняя переменная, является private свойством
	let that = this;			//можно создать специальную переменную для получения контекста этого объекта
	
	function method_1 () {    	    //Объявленные внутри функции являются private методами
		console.log("name", name);	//они имеют доступ к private свойствам и методам напрямую
		console.log("this", this);  //контекстом вызова по умолчанию будет Global object (при 'use starit' - undefined)
		console.log("that", that);  //для получения контекста текущего объекта можно использовать специальную переменную
	}

	let method_2 = function () {	//это тоже private метод, но присвоенный в переменную
		console.log("this", this);
	}.bind(this);					//другой способ получения контекста этого объекта внутри метода


	let show_1 = function () {
		method_1.call(this);		//ещё один способ передать контекст в метод
		method_1.apply(this, arguments);  // или так, если нужно передать какие-то аргументы
	}
	
	//Public свойства и методы
	
	this.gg = 0;        //Указывая свойство объекту, мы делаем его public

	this.show = function () { //аналогично, свойство с присвоенной функцией будет public методом
		
	}

	//Protected свойства и методы
	
	this._gg = 0;   //JS не предусматривает создания настоящих protected свойств, поэтому используется соглашение:
					//свойства и методы, с названием, начинающимся с _ считаются protected, и их нельзя напрямую
					//изменять из кода, хотя, по факту, это обычные public свойства
					
	//Геттеры и сеттеры
	
	this.getName = function () { //Геттер позволяет безопасно передавать значения private свойств внешнему коду
		return name;
	}

	this.setName = function (name) {
		if(true) {					//Сеттер позволяет проверять допустимость переданных значение 
			this.name = name;
		}
		else {
			console.log ('wrong name');
		}
	}

	this.comboName = function(name) { //Комбинированный геттер-сеттер позволяет объеденить оба функционала в одном методе
		if(name) {					
			if(true) {
				this.name = name;
				return name;
			}
			else {
				console.log ('wrong name');
				return false;
			}
		}
		return this.name;
	}

	//Функциональное наследование

	Parent.call(this); //В начале конструктора вызываем конструктор родителя, что приводит к записи в текущий объект свойств и методов
	Parent.apply (this, arguments); //Таким образом можно передать конструктору родителя аргументы

				//При таком подходе наследник не имеет доступа к private свойствам родителя. Значит, в родительском
				//конструкторе необходимо предусмотреть protected свойства по необходимости
	
	let parentMethodTemp = this.parentMethod; //общий способ переопределения методов при функциональном наследовании
	this.parentMethod = function () {
		parentMethodTemp.call(this);
		//...
	}

	//Наследование в прототипном стиле

	this.__proto__ = Object; //можно прямо указать, прочитать или изменить прототип объекта через свойство __proto__
							 //__proto__ используется только для чтения
	
	
	Object.create(proto);    //создаёт пустой объект с прототипом proto

	MyClass.create(null); 	 //таким способом можно создать объект без прототипа, объект не будет иметь
							 //встроенных методов объекта и очень удобен для создания коллекций

	MyClass.prototype = Parent;  //если присвоить prototype конструктора объект, то
								 //созданные ним объекты получат прототипом данный объект

	MyClass.constructor;       //содержит ссылку на конструктор, создавший этот объект

	Parent.apply (this, arguments); //аналогично функциональному стилю, можно вызывать конструктор родителя
									//но в данном случае, это не обязательно, т.к. методы и так есть в prototype
									//это нужно делать, если при конструировании Parent выполняются какие-то операции
									//с документом, вызовы функций, и т.п. и нам нужно, чтобы они отработали (или не вызывать, если не нужно)


	MyClass.prototype.method = function () {}  //подобным способом добавляются свойства и методы всем 
											  //объектам класса. Это более экономично, чем
					//добавлять метод в класс, т.к. копия метода находится в одном
					//экземпляре прототипа, а не в каждом объекте 
					//МЕТОД, ЗАПИСАННЫЙ В ПРОТОТИП, НЕ ИМЕЕТ ДОСТУПА К PRIVATE СВОЙСТВАМ
					//!!! такое присвоение работает глобально и применение его
					//к классам общего назначения и встроенным классам может вызвать конфликты !!!

	
	MyClass.prototype.__proto__ =  Object.create(Parent.prototype); //наследование MyClass от Parent


	MyClass.prototype = Object.create(Parent.prototype); //другой способ унаследовать MyClass от Parent (все методы Parent 
														 //должны быть записаны в Parent.prototype по соглашению) раобтает в IE10-
														 //при таком подходе такая строка должна идти сразу после конструктора MyClass
	MyClass.prototype.constructor = MyClass;			 //желательно после такого присвоения вернуть указание на конструктор
														 //иначе ссылка на конструктор будет утеряна

	MyClass.prototype.method = function () {}		//позволяет переопределить method для MyClass не затрагивая method у Parent

	MyClass.prototype.method = function () {         //позволяет дополнить метод родителя
		Parent.prototype.method.apply (this, arguments);
		//...
	}
}

//синтаксический сахар в ES2015

class MyClass extends Parent {   //такое объявление имеет область видимости как у let

	constructor (name) { 	//будет вызван при вызове new MyClass. Если конструктор не указан, то отработает конструктор родителя
		super(args); 		//Вызывает конструктор родителя. Можно вызвать только из конструктора. До него нельзя обращаться к this    
		this.name = name;
		this.value = 0;
	}  

	method () {}		//автоматически будет добавлен в MwClass.prototype

	super.method ()     //доступ к методу родителя

	static method () {} //статический метод класса
	

	get name () {}		//функция get будет автоматически вызвана при чтении MyClass.name
	set name () {}		//функция set будет автоматически вызвана при записи MyClass.name

	[method()] () {}    //вычисляемое имя метода. В данном случае именем метода будет результат работы method()
}


function Parent () { //Конструктор родительского класса
	this.parentMethod = function () {
		console.log('Родительский метод');
	}
}

let test = new MyClass;

console.dir (test);

}

